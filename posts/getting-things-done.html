---
title: Getting Things Done
slug: getting-things-done
date: 2006-10-19 22:46:00 UTC
description: 
author: Nicholas H.Tollervey
---


	<p>When I explain my <a href="http://ntoll.org/article/all-change">plans for the month of November</a> to my friends, family and (soon-to-be-former) colleagues they inevitably comment on how I'll (not) find the time to do all the tasks I have set myself to a standard that I will be happy with.</p>

	<p>However, in my favour:</p>

	<ul>

		<li>I always set myself unrealistic work-loads and high targets.</li>

		<li>I understand that I do so because I know how to be lazy.</li>

	</ul>

	<p>These are positive character traits for the following reasons:</p>

	<p>By setting unrealistic work-loads I am forced to brutally prioritise and deal with my work in the most efficient way possible. I know that I won't get everything done in the time I have allotted; but what I will get done will have been done in the most efficient way possible to give me a maximum "return" on my time and effort. Think of it as a kind of anti-<a href="http://en.wikipedia.org/wiki/Parkinson's_law">Parkinson's law</a> used in order  to overcome <a href="http://en.wikipedia.org/wiki/Hofstadter%27s_law">Hofstadter's Law</a>.</p>

	<p>This promotes a certain sort of laziness: I'm not going to waste my time doing things I don't need or have to do. If possible, I'll either automate what I want to avoid (with a computer program) or I'll find ways to re-use either my own or others' work to my own advantage (by using freely available software libraries and tools such as the <a href="http://www.textpattern.com">Textpattern</a> content management system that runs this site).</p>

	<p>With these points in mind, my software-development philosophy is encapsulated in the following quote:</p>

	<blockquote>

		<p>"<em>As simple as possible, but no simpler.</em>" (Albert Einstein).</p>

	</blockquote>

	<p>My intention is always to implement <em>only</em> the minimum of required features in the simplest, easiest and most helpful way possible.</p>

	<p>Why?</p>

	<ul>

		<li>The lack of complexity means the code performs better (i.e. there is less for it to do).</li>

		<li>The lack of complexity means that I and any other developer working on the code understand it quicker, making it easier to maintain and modify.</li>

		<li>The lack of complexity makes it less prone to hidden bugs.</li>

		<li>The analytical approach required to implement something as <em>simply as possible</em> demands a thorough understanding of the problem being considered.</li>

	</ul>

	<p>Aiming at a seemingly unrealistic high target is also a means of discovering what one is capable of. This is best illustrated with advice received from a music teacher I once knew: </p>

	<p>I had only recently started playing the Tuba. I was going to audition for a very good local youth orchestra and I wasn't sure if I was good enough to join. His advice was that I wouldn't know unless I auditioned and that, more importantly, if I didn't attend the audition I'd always regret excluding myself from this opportunity. </p>

	<p>Since then I have always had an "<em>if I don't try I'll never find out</em>" attitude and this has worked to my advantage on so many occasions. (I was successful in the audition, too!) </p>

	<p>Finally, seriously considering the possibility of such work, targets, aims and objectives demonstrates a positive outlook, energy, imagination and creativity tempered with a healthy dose of realism and cunning.</p>



 
